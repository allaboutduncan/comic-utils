<!-- templates/index.html -->
{% extends 'base.html' %}

{% block title %}CLU (Comic Library Utilities){% endblock %}

{% block content %}

  <div class="container-lg">
    <h2 class="text-primary-emphasis">File Manager</h2>
    <div class="row">
      <!-- Source Panel -->  
      <div class="col-md-6">
        <h3>Source</h3>
        <!-- New button group for switching between Directories and Downloads -->
        <div class="btn-group mb-2" role="group" aria-label="View Options">
          <button type="button" id="btnDirectories" class="btn btn-outline-primary active" onclick="loadDirectories('/data', 'source');" data-bs-toggle="button" aria-pressed="true">Directories</button>
          <button type="button" id="btnDownloads" class="btn btn-outline-primary" onclick="loadDownloads('{{ target_dir }}', 'source');"data-bs-toggle="button">Downloads</button>
        </div>
        <!-- Filter buttons for source panel -->
        <div id="source-directory-filter" class="mb-2">
          <div class="btn-group d-grid" role="group" aria-label="Directory Filter" style="grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));">
            <!-- Dynamically inserted buttons go here -->
          </div>
        </div>             
        <nav aria-label="breadcrumb">
          <ol id="source-path-display" class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#" onclick="loadDirectories('/data', 'source'); return false;">/data</a>
            </li>
          </ol>
        </nav>
        <ul id="source-list" class="list-group drop-target"></ul>
      </div>      
      <!-- Destination Panel -->
      <div class="col-md-6">
        <h3>Destination</h3>
        <!-- Button Group to Create a Folder -->
        <div class="btn-group mb-2" role="group" aria-label="Folder Options">
          <button type="button" class="btn btn-outline-success" onclick="openCreateFolderModal()">Create Folder</button>
        </div>
        <!-- Filter buttons for destination panel -->
        <div id="destination-directory-filter" class="mb-2">
          <div class="btn-group d-grid" role="group" aria-label="Directory Filter" style="grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));">
            <!-- Dynamically inserted buttons go here -->
          </div>
          <div id="destination-directory-search-row" class="pt-2"></div>
        </div>   
        <nav aria-label="breadcrumb">
          <ol id="destination-path-display" class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#" onclick="loadDirectories('/data', 'destination'); return false;">/data</a>
            </li>
          </ol>
        </nav>
        <ul id="destination-list" class="list-group drop-target"></ul>
      </div>      
    </div>

    <!-- Toast Container -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
      <div id="moveErrorToast" class="toast bg-danger text-white" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header bg-danger text-white">
          <strong class="me-auto">Move Error</strong>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body" id="moveErrorToastBody">
          Move failed.
        </div>
      </div>
    </div>

  </div>

  <!-- Delete Confirmation Modal (Bootstrap 5.3) -->
  <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="deleteModalLabel">Confirm Delete</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          Are you sure you want to delete <strong id="deleteItemName"></strong>?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-danger" id="confirmDeleteBtn">Delete</button>
        </div>
      </div>
    </div>
  </div>
  <!-- End of Delete Confirmation Modal -->

  <!-- Create Folder Modal -->
  <div class="modal fade" id="createFolderModal" tabindex="-1" aria-labelledby="createFolderModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="createFolderModalLabel">Create New Folder</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="createFolderName" class="form-label">Folder Name</label>
            <input type="text" class="form-control" id="createFolderName" placeholder="Enter folder name" />
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="confirmCreateFolderBtn">Create</button>
        </div>
      </div>
    </div>
  </div>
  <!-- End of Create Folder Modal -->

  <!-- Moving Status Modal -->
<div class="modal fade" id="movingModal" tabindex="-1" aria-labelledby="movingModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="movingModalLabel">Moving Items</h5>
        <!-- You can optionally allow closing if desired -->
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="display: none;"></button>
      </div>
      <div class="modal-body">
        <p id="movingStatusText">Preparing to move items...</p>
        <div class="progress">
          <div
            id="movingProgressBar"
            class="progress-bar progress-bar-striped progress-bar-animated"
            role="progressbar"
            style="width: 0%;"
            aria-valuenow="0"
            aria-valuemin="0"
            aria-valuemax="100"
          ></div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- End of Moving Status Modal -->

  <!-- CBZ Info Modal -->
  <div class="modal fade" id="cbzInfoModal" tabindex="-1" aria-labelledby="cbzInfoModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="cbzInfoModalLabel">CBZ Information</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div id="cbzInfoContent">
            <div class="text-center">
              <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <p class="mt-2">Loading CBZ information...</p>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
  <!-- End of CBZ Info Modal -->



  {% endblock %}

  <style>
    .cbz-preview-container {
      border: 1px solid #dee2e6;
      border-radius: 0.375rem;
      padding: 0.5rem;
      background-color: #f8f9fa;
      margin-top: 0.5rem;
    }
    
    .cbz-preview-container img {
      border-radius: 0.25rem;
      box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    }
    
    .cbz-metadata {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }
    
    .list-group-item:hover .cbz-preview-container {
      border-color: #adb5bd;
    }
  </style>

  {% block scripts %}
  {{ super() }}

  <!-- (Optional) jQuery can still be used if desired -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  
  <script>
    // Global variables to track current navigation paths.
    let currentSourcePath = '/data';
    let currentDestinationPath = '/data';
    // Global variables for deletion.
    let deleteTarget = "";
    let deletePanel = ""; // 'source' or 'destination'
    // Global variable to hold selected file paths.
    let selectedFiles = new Set();
    // Global variable to track the last clicked file element (for SHIFT selection).
    let lastClickedFile = null;

    // Store raw data for each panel.
    let sourceDirectoriesData = null;
    let destinationDirectoriesData = null;

    // Track current filter (default is 'all') per panel.
    let currentFilter = { source: 'all', destination: 'all' };

    // Format file size helper function
    function formatSize(bytes) {
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      if (bytes === 0) return '0 B';
      const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
      return (bytes / Math.pow(1024, i)).toFixed(1) + ' ' + sizes[i];
    }

    // Normalize file object (handles both {name, size} or string)
    function normalizeFile(file) {
      if (typeof file === 'object' && file.name) return file;
      return { name: file, size: null };
    }
  
    // Function to send a rename request.
    function renameItem(oldPath, newName, panel) {
      if (typeof oldPath !== "string" || typeof newName !== "string") {
        console.error("Invalid oldPath or newName:", { oldPath, newName });
        alert("Rename failed: Internal path error (non-string input)");
        return;
      }

      const trimmedName = newName.trim();
      if (!trimmedName) {
        alert("Filename cannot be empty.");
        return;
      }

      let pathParts = oldPath.split('/');
      pathParts[pathParts.length - 1] = trimmedName;
      const newPath = pathParts.join('/');

      console.log("renameItem called:");
      console.log("  oldPath:", oldPath);
      console.log("  newName:", newName);
      console.log("  newPath:", newPath);

      fetch('/rename', {
        method: 'POST',
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ old: oldPath, new: newPath })
      })
      .then(response => response.json())
      .then(result => {
        if (result.success) {
          if (panel === 'source') {
            loadDirectories(currentSourcePath, 'source');
          } else {
            loadDirectories(currentDestinationPath, 'destination');
          }
        } else {
          alert("Error renaming item: " + result.error);
        }
      })
      .catch(error => {
        console.error("Error in rename request:", error);
        alert("Rename failed due to a network or server error.");
      });
    }
  
    // Function to send a delete request.
    function deleteItem(target, panel) {
      fetch('/delete', {
        method: 'POST',
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ target: target })
      })
      .then(response => response.json())
      .then(result => {
        if(result.success) {
          if(panel === 'source') {
            loadDirectories(currentSourcePath, 'source');
          } else {
            loadDirectories(currentDestinationPath, 'destination');
          }
        } else {
          alert("Error deleting item: " + result.error);
        }
      })
      .catch(error => {
        console.error("Error in delete request:", error);
      });
    }
  
    // Function to create a list item with edit and delete functionality.
    function createListItem(itemName, fullPath, type, panel, isDraggable) {
      let li = document.createElement("li");
      li.className = "list-group-item d-flex align-items-center justify-content-between";
      li.dataset.fullpath = fullPath;

      let fileData = typeof itemName === "object" ? itemName : { name: itemName, size: null };

      let leftContainer = document.createElement("div");
      leftContainer.className = "d-flex align-items-center";
      
      // Create icon container early to avoid undefined reference
      let iconContainer = document.createElement("div");
      iconContainer.className = "icon-container";

      if (fileData.name.toLowerCase() !== "parent") {
        let icon = document.createElement("i");
        icon.className = (type === "directory") ? "bi bi-folder me-2" : "bi bi-file-earmark-zip me-2";
        if (type === "directory") icon.style.color = "#bf9300";
        leftContainer.appendChild(icon);
      }

      let nameSpan = document.createElement("span");
      if (type === "file" && fileData.size != null) {
        nameSpan.innerHTML = `${fileData.name} <span class="text-info-emphasis small ms-2">(${formatSize(fileData.size)})</span>`;
      } else {
        nameSpan.textContent = fileData.name;
      }
      leftContainer.appendChild(nameSpan);
      
      // Add CBZ info functionality
      if (type === "file" && fileData.name.toLowerCase().endsWith('.cbz')) {
        // Add info button for detailed CBZ information
        const infoBtn = document.createElement("button");
        infoBtn.className = "btn btn-sm btn-outline-secondary ms-2";
        infoBtn.innerHTML = '<i class="bi bi-info-circle"></i>';
        infoBtn.title = "CBZ Information";
        infoBtn.onclick = function(e) {
          e.stopPropagation();
          showCBZInfo(fullPath, fileData.name);
        };
        iconContainer.appendChild(infoBtn);
      }

      if (type === "directory") {
        const infoWrapper = document.createElement("span");
        infoWrapper.className = "me-2";

        const infoIcon = document.createElement("i");
        infoIcon.className = "bi bi-info-circle";
        infoIcon.style.cursor = "pointer";

        const sizeDisplay = document.createElement("span");
        sizeDisplay.className = "text-info-emphasis small ms-2";

        infoIcon.onclick = function (e) {
          e.stopPropagation();
          infoIcon.className = "spinner-border spinner-border-sm";

          fetch(`/folder-size?path=${encodeURIComponent(fullPath)}`)
            .then(res => res.json())
            .then(data => {
              if (data.size != null) {
                let displayText = formatSize(data.size);
                const parts = [];

                if (data.comic_count && data.comic_count > 0) {
                  parts.push(`${data.comic_count} comic${data.comic_count !== 1 ? 's' : ''}`);
                }

                if (data.magazine_count && data.magazine_count > 0) {
                  parts.push(`${data.magazine_count} magazine${data.magazine_count !== 1 ? 's' : ''}`);
                }

                if (parts.length > 0) {
                  displayText += " – " + parts.join(" – ");
                }

                sizeDisplay.textContent = `(${displayText})`;
              } else {
                sizeDisplay.textContent = "(error)";
              }

              // Remove the icon after success
              infoWrapper.removeChild(infoIcon);
            })
            .catch(err => {
              console.error("Error calculating folder size:", err);
              sizeDisplay.textContent = "(error)";
              infoIcon.className = "bi bi-info-circle"; // restore fallback
            });
        };

        infoWrapper.appendChild(infoIcon);
        infoWrapper.appendChild(sizeDisplay);
        iconContainer.appendChild(infoWrapper);
      }

      if (fileData.name !== "Parent") {
        let pencil = document.createElement("i");
        pencil.className = "bi bi-pencil";
        pencil.style.cursor = "pointer";

        pencil.addEventListener("click", e => {
          e.stopPropagation();
          const liElem = e.currentTarget.closest("li");
          const oldPath = liElem.dataset.fullpath;
          const nameSpanElem = liElem.querySelector("span");

          const input = document.createElement("input");
          input.type = "text";
          input.className = "form-control form-control-sm edit-input";
          input.value = typeof fileData === "object" ? fileData.name : fileData;
          input.addEventListener("click", ev => ev.stopPropagation());

          input.addEventListener("keypress", ev => {
            if (ev.key === "Enter") {
              const newName = input.value.trim();
              if (!newName) return alert("Filename cannot be empty.");
              renameItem(oldPath, newName, panel);
            }
          });

          input.addEventListener("blur", () => {
            liElem.replaceChild(leftContainer, input);
          });

          liElem.replaceChild(input, leftContainer);
          input.focus();
        });

        let trash = document.createElement("i");
        trash.className = "bi bi-trash";
        trash.style.cursor = "pointer";
        trash.onclick = function(e) {
          e.stopPropagation();
          deleteTarget = fullPath;
          deletePanel = panel;
          document.getElementById("deleteItemName").textContent = fileData.name;
          new bootstrap.Modal(document.getElementById("deleteModal")).show();
        };

        iconContainer.appendChild(pencil);
        iconContainer.appendChild(trash);
      }

      li.appendChild(leftContainer);
      li.appendChild(iconContainer);

      if (type === "file") {
        li.setAttribute("data-fullpath", fullPath);
        li.addEventListener("click", function(e) {
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            if (selectedFiles.has(fullPath)) {
              selectedFiles.delete(fullPath);
              li.classList.remove("selected");
            } else {
              selectedFiles.add(fullPath);
              li.classList.add("selected");
            }
            lastClickedFile = li;
          } else if (e.shiftKey) {
            let container = li.parentNode;
            let fileItems = Array.from(container.querySelectorAll("li.list-group-item"))
              .filter(item => item.getAttribute("data-fullpath"));
            if (!lastClickedFile) lastClickedFile = li;
            let startIndex = fileItems.indexOf(lastClickedFile);
            let endIndex = fileItems.indexOf(li);
            if (startIndex === -1) startIndex = 0;
            if (endIndex === -1) endIndex = 0;
            let [minIndex, maxIndex] = startIndex < endIndex ? [startIndex, endIndex] : [endIndex, startIndex];
            for (let i = minIndex; i <= maxIndex; i++) {
              let item = fileItems[i];
              selectedFiles.add(item.getAttribute("data-fullpath"));
              item.classList.add("selected");
            }
          } else {
            selectedFiles.clear();
            document.querySelectorAll("li.list-group-item.selected").forEach(item => {
              item.classList.remove("selected");
            });
            selectedFiles.add(fullPath);
            li.classList.add("selected");
            lastClickedFile = li;
          }
          e.stopPropagation();
        });

        li.addEventListener("contextmenu", e => e.preventDefault());
      }

      if (type === "directory") {
        li.onclick = function() {
          currentFilter[panel] = 'all';
          loadDirectories(fullPath, panel);
        };
        if (fileData.name.toLowerCase() !== "parent") {
          li.addEventListener("dragover", e => { e.preventDefault(); li.classList.add("folder-hover"); });
          li.addEventListener("dragleave", e => { li.classList.remove("folder-hover"); });
          li.addEventListener("drop", function(e) {
            e.preventDefault();
            e.stopPropagation();
            li.classList.remove("folder-hover");

            let dataStr = e.dataTransfer.getData("text/plain");
            let items;
            try {
              items = JSON.parse(dataStr);
              if (!Array.isArray(items)) items = [items];
            } catch {
              items = [{ path: dataStr, type: "unknown" }];
            }
            
            let targetDir = fullPath;
            let dedupedPaths = new Set();

            items.forEach(item => {
              let sourcePath = item.path;
              let sourceDir = sourcePath.substring(0, sourcePath.lastIndexOf('/'));
              if (sourceDir !== targetDir && !dedupedPaths.has(sourcePath)) {
                dedupedPaths.add(sourcePath);
              }
            });

            const paths = [...dedupedPaths];
            if (paths.length === 0) return;

            if (paths.length === 1 && items[0].type === "file") {
              moveSingleItem(paths[0], targetDir);
            } else {
              // Pass item types for better progress tracking
              moveMultipleItems(paths, targetDir, panel, items);
            } 
            selectedFiles.clear();
          });
        }
      } else {
        li.onclick = e => e.stopPropagation();
      }

      if (isDraggable) {
        li.classList.add("draggable");
        li.setAttribute("draggable", "true");
        li.addEventListener("dragstart", function(e) {
          if (type === "file") {
            if (selectedFiles.has(fullPath)) {
              e.dataTransfer.setData("text/plain", JSON.stringify([...selectedFiles].map(path => ({ path, type: "file" }))));
            } else {
              selectedFiles.clear();
              document.querySelectorAll("li.list-group-item.selected").forEach(item => item.classList.remove("selected"));
              selectedFiles.add(fullPath);
              li.classList.add("selected");
              e.dataTransfer.setData("text/plain", JSON.stringify([{ path: fullPath, type: "file" }]));
            }
          } else {
            e.dataTransfer.setData("text/plain", JSON.stringify([{ path: fullPath, type: "directory" }]));
          }
        });
      }

      return li;
    }
  
    // Function to dynamically build the filter bar.
    function updateFilterBar(panel, directories) {
      const outerContainer = document.getElementById(`${panel}-directory-filter`);
      if (!outerContainer) return;
      const btnGroup = outerContainer.querySelector('.btn-group');
      if (!btnGroup) return;

      let availableLetters = new Set();
      let hasNonAlpha = false;
  
      directories.forEach(dir => {
        const firstChar = dir.charAt(0).toUpperCase();
        if (firstChar >= 'A' && firstChar <= 'Z') {
          availableLetters.add(firstChar);
        } else {
          hasNonAlpha = true;
        }
      });
  
      let buttonsHtml = '';
      buttonsHtml += `<button type="button" class="btn btn-outline-secondary ${currentFilter[panel] === 'all' ? 'active' : ''}" onclick="filterDirectories('all', '${panel}')">All</button>`;
      
      if (hasNonAlpha) {
        buttonsHtml += `<button type="button" class="btn btn-outline-secondary ${currentFilter[panel] === '#' ? 'active' : ''}" onclick="filterDirectories('#', '${panel}')">#</button>`;
      }
      
      for (let i = 65; i <= 90; i++) {
        const letter = String.fromCharCode(i);
        if (availableLetters.has(letter)) {
          buttonsHtml += `<button type="button" class="btn btn-outline-secondary ${currentFilter[panel] === letter ? 'active' : ''}" onclick="filterDirectories('${letter}', '${panel}')">${letter}</button>`;
        }
      }
      btnGroup.innerHTML = buttonsHtml;
      // --- SEARCH BOX LOGIC (destination only, >25 dirs) ---
      if (panel === 'destination') {
        const searchRow = document.getElementById('destination-directory-search-row');
        if (directories.length > 25) {
          searchRow.innerHTML = `<input type="text" id="destination-directory-search" class="form-control mb-2" placeholder="Type to filter directories..." oninput="onDestinationDirectorySearch(this.value)">`;
        } else {
          searchRow.innerHTML = '';
        }
      }
    }
    
    // --- SEARCH STATE FOR DESTINATION PANEL ---
    let destinationSearchTerm = '';
    function onDestinationDirectorySearch(val) {
      destinationSearchTerm = val.trim().toLowerCase();
      if (destinationDirectoriesData) {
        renderDirectoryListing(destinationDirectoriesData, 'destination');
      }
    }
    // Updated loadDirectories function.
    function loadDirectories(path, panel) {
      console.log("loadDirectories called with path:", path, "panel:", panel);
      document.getElementById('btnDirectories').classList.add('active');
      document.getElementById('btnDownloads').classList.remove('active');
      window.scrollTo({ top: 0, behavior: "smooth" });
      let container = panel === 'source' ? document.getElementById("source-list")
                                         : document.getElementById("destination-list");
      if (!container) {
        console.error("Container not found for panel:", panel);
        return;
      }
      container.innerHTML = `<div class="d-flex justify-content-center my-3">
                                <button class="btn btn-primary" type="button" disabled>
                                  <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                                  Loading...
                                </button>
                              </div>`;
      fetch(`/list-directories?path=${encodeURIComponent(path)}`)
        .then(response => response.json())
        .then(data => {
          console.log("Received data:", data);
          if (panel === 'source') {
            currentSourcePath = data.current_path;
            updateBreadcrumb('source', data.current_path);
            sourceDirectoriesData = data;
            updateFilterBar('source', data.directories);
            renderDirectoryListing(data, 'source');
          } else {
            currentDestinationPath = data.current_path;
            updateBreadcrumb('destination', data.current_path);
            destinationDirectoriesData = data;
            // Reset search filter and input on navigation
            destinationSearchTerm = '';
            const searchInput = document.getElementById('destination-directory-search');
            if (searchInput) searchInput.value = '';
            updateFilterBar('destination', data.directories);
            renderDirectoryListing(data, 'destination');
          }
        })
        .catch(error => {
          console.error("Error loading directories:", error);
          container.innerHTML = `<div class="alert alert-danger" role="alert">
                                    Error loading directory.
                                  </div>`;
        });
    }
  
    // Function to render the directory listing.
    function renderDirectoryListing(data, panel) {
      let container = panel === 'source' ? document.getElementById("source-list")
                                        : document.getElementById("destination-list");
      container.innerHTML = "";
      
      if (data.parent) {
        let parentItem = createListItem("Parent", data.parent, "directory", panel, false);
        parentItem.querySelector("span").innerHTML = `<i class="bi bi-arrow-left-square me-2"></i> Parent`;
        container.appendChild(parentItem);
      }
      
      let filter = currentFilter[panel];
      let directoriesToShow = data.directories.filter(dir => {
        // --- SEARCH FILTER FOR DESTINATION PANEL ---
        if (panel === 'destination' && destinationSearchTerm) {
          if (!dir.toLowerCase().includes(destinationSearchTerm)) return false;
        }
        // --- END SEARCH FILTER ---
        if (filter === 'all') return true;
        if (filter === '#') return !/^[A-Za-z]/.test(dir.charAt(0));
        return dir.charAt(0).toUpperCase() === filter;
      });
      
      directoriesToShow.forEach(dir => {
        let fullPath = data.current_path + "/" + dir;
        let item = createListItem(dir, fullPath, "directory", panel, true);
        container.appendChild(item);
      });
      
      if (filter === 'all') {
        data.files.forEach(file => {
          const fileData = normalizeFile(file);
          const fullPath = data.current_path + "/" + fileData.name;
          let fileItem = createListItem(fileData, fullPath, "file", panel, true);
          container.appendChild(fileItem);
        });
      }
      
      // For the destination panel, only add the drop target if the directory is truly empty.
      if (panel === 'destination' && data.directories.length === 0 && data.files.length === 0) {
        let dropTargetItem = document.createElement("li");
        dropTargetItem.className = "list-group-item text-center drop-target-item";
        dropTargetItem.textContent = "... Drop Files Here";
        
        dropTargetItem.addEventListener("dragover", function(e) {
          e.preventDefault();
          e.stopPropagation();
          dropTargetItem.classList.add("folder-hover");
        });
        dropTargetItem.addEventListener("dragleave", function(e) {
          e.stopPropagation();
          dropTargetItem.classList.remove("folder-hover");
        });
        dropTargetItem.addEventListener("drop", function(e) {
          e.preventDefault();
          e.stopPropagation();
          dropTargetItem.classList.remove("folder-hover");
          let dataStr = e.dataTransfer.getData("text/plain");
          let items;
          try {
            items = JSON.parse(dataStr);
            if (!Array.isArray(items)) {
              items = [items];
            }
          } catch (err) {
            items = [{ path: dataStr, type: "unknown" }];
          }
          let paths = items.map(item => item.path);
          moveMultipleItems(paths, data.current_path, panel);
          selectedFiles.clear();
        });
        
        container.appendChild(dropTargetItem);
      }
    }
  
    // Function to filter directories based on the selected letter.
    function filterDirectories(letter, panel) {
      if (currentFilter[panel] === letter) {
        currentFilter[panel] = 'all';
      } else {
        currentFilter[panel] = letter;
      }
      let filterContainer = document.getElementById(panel + "-directory-filter");
      if (filterContainer) {
        let btnGroup = filterContainer.querySelector('.btn-group');
        if (btnGroup) {
          let buttons = btnGroup.querySelectorAll("button");
          buttons.forEach(btn => {
            let btnText = btn.textContent.trim();
            if ((currentFilter[panel] === 'all' && btnText === 'All') || btnText === currentFilter[panel]) {
              btn.classList.add("active");
            } else {
              btn.classList.remove("active");
            }
          });
        }
      }
      if (panel === 'source' && sourceDirectoriesData) {
        renderDirectoryListing(sourceDirectoriesData, panel);
      } else if (panel === 'destination' && destinationDirectoriesData) {
        renderDirectoryListing(destinationDirectoriesData, panel);
      }
    }
  
    // New loadDownloads function to fetch downloads data.
    function loadDownloads(path, panel) {
      console.log("loadDownloads called with path:", path, "panel:", panel);
      document.getElementById('btnDownloads').classList.add('active');
      document.getElementById('btnDirectories').classList.remove('active');
      window.scrollTo({ top: 0, behavior: "smooth" });
      let container = panel === 'source' ? document.getElementById("source-list")
                                         : document.getElementById("destination-list");
      if (!container) {
        console.error("Container not found for panel:", panel);
        return;
      }
      container.innerHTML = `<div class="d-flex justify-content-center my-3">
                                <button class="btn btn-primary" type="button" disabled>
                                  <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                                  Loading...
                                </button>
                              </div>`;
      fetch(`/list-downloads?path=${encodeURIComponent(path)}`)
        .then(response => response.json())
        .then(data => {
          console.log("Received data:", data);
          container.innerHTML = "";
          if (panel === 'source') {
            currentSourcePath = data.current_path;
            updateBreadcrumb('source', data.current_path);
          } else {
            currentDestinationPath = data.current_path;
            updateBreadcrumb('destination', data.current_path);
          }
          if (data.parent) {
            let parentItem = createListItem("Parent", data.parent, "directory", panel, false);
            parentItem.querySelector("span").innerHTML = `<i class="bi bi-arrow-left-square me-2"></i> Parent`;
            container.appendChild(parentItem);
          }
          data.directories.forEach(dir => {
            const dirData = normalizeFile(dir);
            const fullPath = data.current_path + "/" + dirData.name;
            const item = createListItem(dirData, fullPath, "directory", panel, true);
            container.appendChild(item);
          });
          data.files.forEach(file => {
            const fileData = normalizeFile(file);
            const fullPath = data.current_path + "/" + fileData.name;
            let fileItem = createListItem(fileData, fullPath, "file", panel, true);
            container.appendChild(fileItem);
          });
        })
        .catch(error => {
          console.error("Error loading downloads:", error);
          container.innerHTML = `<div class="alert alert-danger" role="alert">
                                    Error loading downloads.
                                  </div>`;
        });
    }
  
    // Initial load for both panels.
    loadDirectories(currentSourcePath, 'source');
    loadDirectories(currentDestinationPath, 'destination');
  
    // Function to move an item.
    function moveItem(source, destination) {
      fetch('/move', {
        method: 'POST',
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ source: source, destination: destination })
      })
      .then(response => response.json())
      .then(result => {
        if(result.success) {
          loadDirectories(currentSourcePath, 'source');
          loadDirectories(currentDestinationPath, 'destination');
        } else {
          alert("Error moving file: " + result.error);
        }
      })
      .catch(error => {
        console.error("Error in move request:", error);
      });
    }

    // Patch moveSingleItem to tolerate file objects
    function moveSingleItem(sourcePath, targetFolder) {
      let actualPath = typeof sourcePath === 'object' ? sourcePath.path || sourcePath.name : sourcePath;
      showMovingModal();
      let fileName = actualPath.split('/').pop();
      setMovingStatus(`Moving ${fileName}`);
      updateMovingProgress(0);

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/move", true);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.setRequestHeader("X-Stream", "true");

      let finished = false;
      let lastResponseLength = 0;

      function completeMove() {
        if (!finished) {
          finished = true;
          xhr.onprogress = xhr.onreadystatechange = xhr.onerror = null;
          updateMovingProgress(100);
          setTimeout(() => {
            hideMovingModal();
            setTimeout(() => {
              loadDirectories(currentSourcePath, 'source');
              loadDirectories(currentDestinationPath, 'destination');
            }, 300);
          }, 200);
        }
      }

      xhr.onprogress = function(e) {
        let newData = xhr.responseText.substring(lastResponseLength);
        lastResponseLength = xhr.responseText.length;
        let events = newData.split("\n\n");
        events.forEach(event => {
          if (event.startsWith("data: ")) {
            let progressData = event.slice(6).trim();
            if (progressData === "done") {
              completeMove();
            } else if (progressData.startsWith("error:")) {
              console.error("Error:", progressData);
            } else {
              let percentComplete = parseInt(progressData);
              updateMovingProgress(percentComplete);
            }
          }
        });
      };

      xhr.onreadystatechange = function() {
        if (xhr.readyState === XMLHttpRequest.DONE && !finished) {
          completeMove();
        }
      };

      xhr.onerror = function() {
        alert("Error moving file: " + xhr.statusText);
        hideMovingModal();
      };

      const payload = {
        source: actualPath,
        destination: targetFolder + "/" + fileName
      };

      xhr.send(JSON.stringify(payload));
    }

    // Set up drop events for a given panel element.
    function setupDropEvents(element, panel) {
      let autoScrollInterval = null;
      function startAutoScroll(direction) {
        if (autoScrollInterval !== null) return;
        autoScrollInterval = setInterval(() => {
          if (direction === "up") {
            element.scrollTop -= 5;
          } else if (direction === "down") {
            element.scrollTop += 5;
          }
        }, 50);
      }
      function stopAutoScroll() {
        if (autoScrollInterval !== null) {
          clearInterval(autoScrollInterval);
          autoScrollInterval = null;
        }
      }
      element.addEventListener("dragover", function(e) {
        e.preventDefault();
        element.classList.add("hover");
        let rect = element.getBoundingClientRect();
        let threshold = 50;
        let scrollDirection = null;
        if (e.clientY - rect.top < threshold) {
          scrollDirection = "up";
        } else if (rect.bottom - e.clientY < threshold) {
          scrollDirection = "down";
        }
        if (scrollDirection) {
          startAutoScroll(scrollDirection);
        } else {
          stopAutoScroll();
        }
      });
      element.addEventListener("dragleave", function(e) {
        element.classList.remove("hover");
        stopAutoScroll();
      });
      element.addEventListener("drop", function(e) {
        e.preventDefault();
        element.classList.remove("hover");
        stopAutoScroll();
        let dataStr = e.dataTransfer.getData("text/plain");
        let items;
        try {
          items = JSON.parse(dataStr);
          if (!Array.isArray(items)) {
            items = [items];
          }
        } catch (err) {
          items = [{ path: dataStr, type: "unknown" }];
        }
        let targetPath = panel === 'source' ? currentSourcePath : currentDestinationPath;
        
        // Filter out items whose source folder is the same as the target folder.
        let validItems = items.filter(item => {
          let sourcePath = item.path;
          let sourceDir = sourcePath.substring(0, sourcePath.lastIndexOf('/'));
          return sourceDir !== targetPath;
        });
        if (validItems.length === 0) {
          console.log("All items dropped are in the same directory. Move cancelled.");
          return;
        }
        
        // If only one valid file item is being moved, call moveSingleItem for progress.
        const paths = validItems.map(item => item.path);

        // If *only one item is selected*, and no other selections exist, use moveSingleItem
        if (paths.length === 1 && selectedFiles.size <= 1 && validItems[0].type === "file") {
          moveSingleItem(paths[0], targetPath);
        } else {
          // Pass item types for better progress tracking
          const itemsWithTypes = validItems.map(item => ({
            path: item.path,
            type: item.type
          }));
          moveMultipleItems(paths, targetPath, panel, itemsWithTypes);
        }
        selectedFiles.clear();
      });
    }
  
    // Update the breadcrumb display for source or destination panel.
    function updateBreadcrumb(panel, fullPath) {
      let breadcrumbEl;
      if (panel === 'source') {
        breadcrumbEl = document.getElementById("source-path-display");
      } else if (panel === 'destination') {
        breadcrumbEl = document.getElementById("destination-path-display");
      } else {
        console.error("Invalid panel:", panel);
        return;
      }
      breadcrumbEl.innerHTML = "";
      let parts = fullPath.split('/').filter(Boolean);
      let pathSoFar = "";
      parts.forEach((part, index) => {
        pathSoFar += "/" + part;
        let currentPartPath = pathSoFar;
        const li = document.createElement("li");
        li.className = "breadcrumb-item";
        if (index === parts.length - 1) {
          li.classList.add("active");
          li.setAttribute("aria-current", "page");
          li.textContent = part;
        } else {
          const a = document.createElement("a");
          a.href = "#";
          a.textContent = part;
          a.onclick = function(e) {
            e.preventDefault();
            console.log("Breadcrumb clicked:", currentPartPath, "Panel:", panel);
            loadDirectories(currentPartPath, panel);
          };
          li.appendChild(a);
        }
        breadcrumbEl.appendChild(li);
      });
    }
  
    // Attach drop events.
    setupDropEvents(document.getElementById("source-list"), 'source');
    setupDropEvents(document.getElementById("destination-list"), 'destination');
  
    // Create Folder Modal functionality.
    let createFolderModalEl = document.getElementById('createFolderModal');
    let createFolderNameInput = document.getElementById('createFolderName');
    let confirmCreateFolderBtn = document.getElementById('confirmCreateFolderBtn');

    // Focus input when modal opens
    createFolderModalEl.addEventListener('shown.bs.modal', function () {
      createFolderNameInput.focus();
    });

    // Open modal function
    function openCreateFolderModal() {
      document.getElementById('createFolderName').value = '';
      let createFolderModal = new bootstrap.Modal(createFolderModalEl);
      createFolderModal.show();
    }

    // Function to create folder
    function createFolder() {
      let folderName = createFolderNameInput.value.trim();
      if (!folderName) {
        alert('Folder name cannot be empty.');
        createFolderNameInput.focus();
        return;
      }
      
      let fullPath = currentDestinationPath + '/' + folderName;
      
      fetch('/create-folder', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path: fullPath })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          let createFolderModal = bootstrap.Modal.getInstance(createFolderModalEl);
          createFolderModal.hide();
          currentFilter['destination'] = 'all';
          loadDirectories(currentDestinationPath, 'destination');
        } else {
          alert(data.error || 'Error creating folder.');
        }
      })
      .catch(err => {
        console.error('Error creating folder:', err);
        alert('An unexpected error occurred.');
      });
    }

    // Click event for "Create" button
    confirmCreateFolderBtn.addEventListener('click', createFolder);

    // Listen for "Enter" keypress inside input field
    createFolderNameInput.addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        event.preventDefault(); // Prevent form submission if inside a form
        createFolder();
      }
    });
  
    // Moving Status Modal Functions.
    let movingModalEl = document.getElementById('movingModal');
    let movingStatusText = document.getElementById('movingStatusText');
    let movingProgressBar = document.getElementById('movingProgressBar');
    let movingModal = new bootstrap.Modal(movingModalEl, {
      backdrop: 'static',
      keyboard: false
    });
    function showMovingModal() {
      movingStatusText.textContent = "Preparing to move items...";
      movingProgressBar.style.width = "0%";
      movingProgressBar.setAttribute('aria-valuenow', 0);
      movingModal.show();
    }
    function hideMovingModal() {
      movingModal.hide();
    }
    function setMovingStatus(message) {
      movingStatusText.textContent = message;
    }
    function updateMovingProgress(percentage) {
      movingProgressBar.style.width = percentage + "%";
      movingProgressBar.setAttribute('aria-valuenow', percentage);
    }
    // Enhanced moveMultipleItems with better directory progress
    function moveMultipleItems(filePaths, targetFolder, panel, itemsWithTypes = null) {
      showMovingModal();
      let totalCount = filePaths.length;
      let currentIndex = 0;
      let totalFilesToMove = 0;
      let filesMoved = 0;
      
      // First, count files in directories to get accurate progress
      function countFilesInDirectories() {
        let directoriesToCount = [];
        
        if (itemsWithTypes) {
          // Use the provided type information
          directoriesToCount = itemsWithTypes
            .filter(item => item.type === "directory")
            .map(item => item.path);
        } else {
          // Fallback: check all paths
          directoriesToCount = filePaths;
        }
        
        if (directoriesToCount.length === 0) {
          // No directories, proceed with normal counting
          totalFilesToMove = filePaths.length;
          startMoving();
          return;
        }
        
        let countPromises = [];
        directoriesToCount.forEach(path => {
          countPromises.push(
            fetch(`/count-files?path=${encodeURIComponent(path)}`)
              .then(res => res.json())
              .then(data => ({ path, fileCount: data.file_count || 0 }))
              .catch(err => ({ path, fileCount: 0 }))
          );
        });
        
        Promise.all(countPromises).then(results => {
          // Calculate total files to move
          totalFilesToMove = results.reduce((sum, result) => sum + result.fileCount, 0);
          // Add individual files (non-directories)
          const fileItems = itemsWithTypes ? 
            itemsWithTypes.filter(item => item.type === "file").length : 
            filePaths.length - directoriesToCount.length;
          totalFilesToMove += fileItems;
          
          if (totalFilesToMove === 0) {
            totalFilesToMove = filePaths.length; // Fallback to item count
          }
          
          startMoving();
        });
      }
      
      function startMoving() {
        moveNext();
      }
      
      function moveNext() {
        if (currentIndex >= totalCount) {
          hideMovingModal();
          loadDirectories(currentSourcePath, 'source');
          loadDirectories(currentDestinationPath, 'destination');
          return;
        }
        
        let fileObj = normalizeFile(filePaths[currentIndex]);
        let sourcePath = typeof fileObj === 'string' ? fileObj : fileObj.path || fileObj.name;
        let fileName = sourcePath.split('/').pop();
        
        // Determine if this is a directory based on item type or by checking filesystem
        const currentItem = itemsWithTypes ? itemsWithTypes[currentIndex] : null;
        const isDirectory = currentItem ? currentItem.type === "directory" : null;
        
        let movePromise;
        
        if (isDirectory !== null) {
          // We have type information, use it
          if (isDirectory) {
            // For directories, use item-based progress since we can't track individual files
            setMovingStatus(`Moving directory ${fileName} (${currentIndex + 1} of ${totalCount} items)`);
            
            let percentage = Math.floor((currentIndex / totalCount) * 100);
            updateMovingProgress(percentage);
            
            movePromise = fetch('/move', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                source: sourcePath,
                destination: targetFolder + '/' + fileName
              })
            });
          } else {
            // For files, use file-based progress
            setMovingStatus(`Moving file ${fileName} (${filesMoved + 1} of ${totalFilesToMove} files)`);
            
            let percentage;
            if (totalFilesToMove > 0) {
              percentage = Math.floor((filesMoved / totalFilesToMove) * 100);
            } else {
              percentage = Math.floor((currentIndex / totalCount) * 100);
            }
            updateMovingProgress(percentage);
            
            movePromise = fetch('/move', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                source: sourcePath,
                destination: targetFolder + '/' + fileName
              })
            });
          }
        } else {
          // Fallback: check filesystem
          movePromise = fetch(`/count-files?path=${encodeURIComponent(sourcePath)}`)
            .then(res => res.json())
            .then(data => {
              const isDirectory = data.file_count !== undefined;
              const fileCount = data.file_count || 0;
              
              if (isDirectory && fileCount > 0) {
                // This is a directory with files - show progress based on items
                setMovingStatus(`Moving directory ${fileName} (${currentIndex + 1} of ${totalCount} items)`);
              } else {
                // This is a file or empty directory
                setMovingStatus(`Moving ${fileName} (${currentIndex + 1} of ${totalCount} items)`);
              }
              
              let percentage = Math.floor((currentIndex / totalCount) * 100);
              updateMovingProgress(percentage);
              
              return fetch('/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  source: sourcePath,
                  destination: targetFolder + '/' + fileName
                })
              });
            });
        }
        
        movePromise
          .then(res => res.json())
          .then(data => {
            if (!data.success) {
              console.warn("Move reported error, but continuing:", data.error);
            }
            
            // Update progress counters
            const currentItem = itemsWithTypes ? itemsWithTypes[currentIndex] : null;
            const isDirectory = currentItem ? currentItem.type === "directory" : null;
            
            if (isDirectory) {
              // For directories, we can't track individual files, so just increment item counter
              // The progress bar will update based on currentIndex/totalCount
            } else {
              // For files, increment file counter for file-based progress
              if (totalFilesToMove > 0) {
                filesMoved += 1;
              }
            }
            
            currentIndex++;
            moveNext();
          })
          .catch(err => {
            const fileName = filePaths[currentIndex].split('/').pop();
            const detailMessage = `Failed to move "${fileName}" → "${targetFolder}": ${err.message || err}`;
            
            console.error("Move failed:", {
              file: fileName,
              source: filePaths[currentIndex],
              destination: targetFolder + '/' + fileName,
              error: err
            });

            if (window.bootstrap && document.getElementById("moveErrorToast")) {
              document.getElementById("moveErrorToastBody").textContent = detailMessage;
              bootstrap.Toast.getOrCreateInstance(document.getElementById("moveErrorToast")).show();
            } else {
              alert(detailMessage);
            }

            currentIndex++;
            moveNext();
          });
      }
      
      // Start the process
      countFilesInDirectories();
    }
  


    // Function to show detailed CBZ information
    function showCBZInfo(filePath, fileName) {
      const modal = new bootstrap.Modal(document.getElementById('cbzInfoModal'));
      const content = document.getElementById('cbzInfoContent');
      
      // Reset content
      content.innerHTML = `
        <div class="text-center">
          <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2">Loading CBZ information...</p>
        </div>
      `;
      
      modal.show();
      
      // Load metadata
      fetch(`/cbz-metadata?path=${encodeURIComponent(filePath)}`)
        .then(res => res.json())
        .then(data => {
          console.log('CBZ metadata response:', data);
          if (data.comicinfo) {
            console.log('ComicInfo data:', data.comicinfo);
          }
          
          let html = `
            <div class="row">
              <div class="col-md-6">
          `;
          
          // Add ComicInfo section if available
          if (data.comicinfo) {
            html += `
                <h6>Comic Information</h6>
                <div class="card">
                  <div class="card-body">
                    <div class="row">
            `;
            
            const comicInfo = data.comicinfo;
            console.log('Processing comicInfo:', comicInfo);
            
            // Define field groups for better organization
            const fieldGroups = [
              {
                title: "Basic Information",
                fields: [
                  { key: 'Title', label: 'Title' },
                  { key: 'Series', label: 'Series' },
                  { key: 'Number', label: 'Number' },
                  { key: 'Count', label: 'Count' },
                  { key: 'Volume', label: 'Volume' },
                  { key: 'AlternateSeries', label: 'Alternate Series' },
                  { key: 'AlternateNumber', label: 'Alternate Number' },
                  { key: 'AlternateCount', label: 'Alternate Count' }
                ]
              },
              {
                title: "Publication Details",
                fields: [
                  { key: 'Year', label: 'Year' },
                  { key: 'Month', label: 'Month' },
                  { key: 'Day', label: 'Day' },
                  { key: 'Publisher', label: 'Publisher' },
                  { key: 'Imprint', label: 'Imprint' },
                  { key: 'Format', label: 'Format' },
                  { key: 'PageCount', label: 'Page Count' },
                  { key: 'LanguageISO', label: 'Language' }
                ]
              },
              {
                title: "Creative Team",
                fields: [
                  { key: 'Writer', label: 'Writer' },
                  { key: 'Penciller', label: 'Penciller' },
                  { key: 'Inker', label: 'Inker' },
                  { key: 'Colorist', label: 'Colorist' },
                  { key: 'Letterer', label: 'Letterer' },
                  { key: 'CoverArtist', label: 'Cover Artist' },
                  { key: 'Editor', label: 'Editor' }
                ]
              },
              {
                title: "Content Details",
                fields: [
                  { key: 'Genre', label: 'Genre' },
                  { key: 'Characters', label: 'Characters' },
                  { key: 'Teams', label: 'Teams' },
                  { key: 'Locations', label: 'Locations' },
                  { key: 'StoryArc', label: 'Story Arc' },
                  { key: 'SeriesGroup', label: 'Series Group' },
                  { key: 'MainCharacterOrTeam', label: 'Main Character/Team' },
                  { key: 'AgeRating', label: 'Age Rating' }
                ]
              },
              {
                title: "Additional Information",
                fields: [
                  { key: 'Summary', label: 'Summary' },
                  { key: 'Notes', label: 'Notes' },
                  { key: 'Web', label: 'Web' },
                  { key: 'ScanInformation', label: 'Scan Information' },
                  { key: 'Review', label: 'Review' },
                  { key: 'CommunityRating', label: 'Community Rating' },
                  { key: 'BlackAndWhite', label: 'Black & White' },
                  { key: 'Manga', label: 'Manga' }
                ],
                fullWidth: true
              }
            ];
            
            // Generate HTML for each field group
            fieldGroups.forEach(group => {
              const hasFields = group.fields.some(field => comicInfo[field.key]);
              console.log(`Group "${group.title}" has fields:`, hasFields);
              if (hasFields) {
                const colClass = group.fullWidth ? 'col-md-12' : 'col-md-6';
                html += `
                  <div class="${colClass} mb-3">
                    <h6 class="text-muted small">${group.title}</h6>
                    <ul class="list-unstyled small">
                `;
                
                group.fields.forEach(field => {
                  if (comicInfo[field.key] && comicInfo[field.key] !== '' && comicInfo[field.key] !== -1) {
                    let value = comicInfo[field.key];
                    
                    // Format special values
                    if (field.key === 'BlackAndWhite' || field.key === 'Manga') {
                      if (value === 'Yes') value = 'Yes';
                      else if (value === 'No') value = 'No';
                      else if (value === 'YesAndRightToLeft') value = 'Yes (Right to Left)';
                      else value = 'Unknown';
                    }
                    
                    if (field.key === 'CommunityRating' && value > 0) {
                      value = `${value}/5`;
                    }
                    
                    html += `<li><strong>${field.label}:</strong> ${value}</li>`;
                  }
                });
                
                html += `
                    </ul>
                  </div>
                `;
              }
            });
            
            html += `
                      </div>
                    </div>
                  </div>
            `;
          } else {
            html += `<p class="text-muted">No ComicInfo.xml found</p>`;
          }
          
          html += `
              </div>
              <div class="col-md-6">
                <h6>Preview</h6>
                <div id="cbzPreviewContainer" class="text-center">
                  <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          `;
          
          // Add File Information and First Files below the columns
          html += `
            <div class="row mt-4">
              <div class="col-12">
                <h6>File Information</h6>
                <ul class="list-unstyled">
                  <li><strong>Name:</strong> ${fileName}</li>
                  <li><strong>Size:</strong> ${formatSize(data.file_size)}</li>
                  <li><strong>Total Files:</strong> ${data.total_files}</li>
                  <li><strong>Image Files:</strong> ${data.image_files}</li>
                </ul>
                
                <h6 class="mt-4">First Files</h6>
                <ul class="list-unstyled small">
          `;
          
          // Add file list
          if (data.file_list && data.file_list.length > 0) {
            data.file_list.forEach(file => {
              html += `<li><code>${file}</code></li>`;
            });
          }
          
          html += `
                </ul>
              </div>
            </div>
          `;
          
          content.innerHTML = html;
          
          // Load preview
          fetch(`/cbz-preview?path=${encodeURIComponent(filePath)}&size=large`)
            .then(res => res.json())
            .then(previewData => {
              const previewContainer = document.getElementById('cbzPreviewContainer');
              if (previewData.success) {
                previewContainer.innerHTML = `
                  <img src="${previewData.preview}" class="img-fluid" style="max-width: 100%; max-height: 600px;" alt="CBZ Preview">
                  <p class="small text-muted mt-2">${previewData.file_name}</p>
                  <small class="text-muted">Images: ${previewData.total_images} | Original: ${previewData.original_size.width}×${previewData.original_size.height} | Display: ${previewData.display_size.width}×${previewData.display_size.height}</small>
                `;
              } else {
                previewContainer.innerHTML = '<p class="text-muted">Preview not available</p>';
              }
            })
            .catch(err => {
              document.getElementById('cbzPreviewContainer').innerHTML = '<p class="text-danger">Error loading preview</p>';
            });
        })
        .catch(err => {
          content.innerHTML = `
            <div class="alert alert-danger">
              Error loading CBZ information: ${err.message}
            </div>
          `;
        });
    }

    // Delete confirmation handler.
    document.getElementById("confirmDeleteBtn").addEventListener("click", function() {
      let deleteModalEl = document.getElementById("deleteModal");
      let deleteModal = bootstrap.Modal.getInstance(deleteModalEl);
      deleteModal.hide();
      deleteItem(deleteTarget, deletePanel);
    });
  </script>  
  
  {% endblock %}