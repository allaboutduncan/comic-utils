{% extends 'base.html' %}

{% block title %}CLU: Settings Page{% endblock %}

{% block content %}

<style>
    /* Spinning icon for cache operations */
    .spin {
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
</style>

<div class="container-lg">
    <h2 class="text-primary-emphasis">App Settings</h2>
    <form method="POST" class="mt-4">
        
        <!-- Missing Issue Configuration -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Missing Issue Configuration</h4>
            <p class="text-muted">Update these settings to ignore terms or files when the app is performing a <strong>Missing Issue</strong> scan.</p>

            <div class="row">
                <div class="col-md-6">
                    <label for="ignored_terms" class="form-label">IGNORED TERMS:</label>
                    <input type="text" name="ignored_terms" id="ignored_terms" value="{{ ignored_terms }}" class="form-control">
                    <small class="form-text text-muted">
                        Enter words or terms to ignore while performing a Missing Issue search. Terms must be comma-separated.
                    </small>
                </div>

                <div class="col-md-6">
                    <label for="ignored_files" class="form-label">IGNORED FILES:</label>
                    <input type="text" name="ignored_files" id="ignored_files" value="{{ ignored_files }}" class="form-control">
                    <small class="form-text text-muted">
                        Enter comma-separated file names to ignore when checking for missing issues (e.g., cover.jpg, cvinfo).
                    </small>
                </div>
            </div>
        </div>

        <!-- Directory Processing Configuration -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Directory & File Processing Settings</h4>
            <p class="text-muted">Settings related to Directory processing features.</p>

             <!-- Checkboxes for Traverse Subdirectories -->
             <div class="row">
                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="convertSubdirectories" name="convertSubdirectories" {% if convertSubdirectories %}checked{% endif %}>
                        <label class="form-check-label" for="convertSubdirectories">{% if convertSubdirectories %}Disable{% else %}Enable{% endif %} Subdirectories for Conversion</label>
                        <small class="form-text text-muted">
                            <br />If enabled, when performing CBR --> CBZ conversion on a directory, CLU will convert all files in subdirectories as well.
                        </small>
                    </div>
                </div>

                <!-- Placeholder 
                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="readSubdirectories" name="readSubdirectories" {% if readSubdirectories %}checked{% endif %}>
                        <label class="form-check-label" for="readSubdirectories">{% if readSubdirectories %}Disable{% else %}Enable{% endif %} Processing Sub-Directories</label>
                        <small class="form-text text-muted">
                            <br />If enabled, the app will process files in sub-directories of your <code>{{ watch }}</code> folder.
                        </small>
                    </div>
                </div> -->
            </div>
            <p class="text-muted">Settings related to Directory & File processing features.</p>
            <div class="row">
                <div class="col-md-6">
                    <label for="skippedFiles" class="form-label">SKIPPED FILE TYPES:</label>
                    <input type="text" name="skippedFiles" id="skippedFiles" value="{{ skippedFiles }}" class="form-control">
                    <small class="form-text text-muted">
                        When any operation unpacks a RAR/ZIP File, files with these extensions will be skipped. They will be re-added to the archive.
                    </small>
                </div>

                <div class="col-md-6">
                    <label for="deletedFiles" class="form-label">DELETED FILE TYPES:</label>
                    <input type="text" name="deletedFiles" id="deletedFiles" value="{{ deletedFiles }}" class="form-control">
                    <small class="form-text text-muted">
                        When any operation unpacks a RAR/ZIP File, files with these extensions will deleted before the file is re-packed.
                    </small>
                </div>
            </div>

        </div>

        <!-- Folder Monitoring Configuration -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Folder Monitoring</h4>
            <p class="text-muted">Configure the <code>Watched</code> and <code>Target</code> folders. Other monitoring features can be adjusted here as well.</p>

            <div class="row">
                <div class="col-md-6">
                    <label for="watch" class="form-label">WATCH:</label>
                    <input type="text" name="watch" id="watch" value="{{ watch }}" class="form-control">
                    <small class="form-text text-muted">
                        Enter the path to the directory to monitor for downloaded files.
                    </small>
                </div>

                <div class="col-md-6">
                    <label for="target" class="form-label">TARGET:</label>
                    <input type="text" name="target" id="target" value="{{ target }}" class="form-control">
                    <small class="form-text text-muted">
                        Enter the path where renamed files will be moved.
                    </small>
                </div>
            </div>

            <hr>

            <!-- Checkboxes for AutoConvert & Subdirectories -->
            <div class="row">
                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="autoConvert" name="autoConvert" {% if autoConvert %}checked{% endif %}>
                        <label class="form-check-label" for="autoConvert">{% if autoConvert %}Disable{% else %}Enable{% endif %} Auto CBZ Conversion</label>
                        <small class="form-text text-muted">
                            <br />Enables auto-conversion of CBR/RAR files to CBZ in your Watch folder.
                        </small>
                    </div>
                </div>

                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="readSubdirectories" name="readSubdirectories" {% if readSubdirectories %}checked{% endif %}>
                        <label class="form-check-label" for="readSubdirectories">{% if readSubdirectories %}Disable{% else %}Enable{% endif %} Processing Sub-Directories</label>
                        <small class="form-text text-muted">
                            <br />If enabled, the app will process files in sub-directories of your <code>{{ watch }}</code> folder.
                        </small>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="autoUnpack" name="autoUnpack" {% if autoUnpack %}checked{% endif %}>
                        <label class="form-check-label" for="autoUnpack">{% if autoUnpack %}Disable{% else %}Enable{% endif %} Auto ZIP Extraction</label>
                        <small class="form-text text-muted">
                            <br />When enabled, ZIP files placed in the Watch folder will automatically be unzipped.
                        </small>
                    </div>
                </div>

                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="moveDirectory" name="moveDirectory" {% if moveDirectory %}checked{% endif %}>
                        <label class="form-check-label" for="moveDirectory">{% if moveDirectory %}Disable{% else %}Enable{% endif %} Move Sub-Directories</label>
                        <small class="form-text text-muted">
                            <br />If enabled, when processing files in your <code>{{ watch }}</code> folder, the sub-dirctories will be moved as well.
                        </small>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12">
                    <label for="ignored_extensions" class="form-label">IGNORED EXTENSIONS:</label>
                    <input type="text" name="ignored_extensions" id="ignored_extensions" value="{{ ignored_extensions }}" class="form-control">
                    <small class="form-text text-muted">
                        Enter extensions to ignore when monitoring files (e.g., .tmp, .crdownload).
                    </small>
                </div>
            </div>

            <hr>

            <!-- Cleanup Configuration -->
            <div class="row">
                <div class="col-md-6">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="autoCleanupOrphanFiles" name="autoCleanupOrphanFiles" {% if autoCleanupOrphanFiles %}checked{% endif %}>
                        <label class="form-check-label" for="autoCleanupOrphanFiles">{% if autoCleanupOrphanFiles %}Disable{% else %}Enable{% endif %} Auto Cleanup Orphan Files</label>
                        <small class="form-text text-muted">
                            <br />Automatically removes temporary download files (.crdownload, .tmp, .part) from the downloads folder.
                        </small>
                    </div>
                </div>

                <div class="col-md-6">
                    <label for="cleanupIntervalHours" class="form-label">CLEANUP INTERVAL (HOURS):</label>
                    <input type="number" name="cleanupIntervalHours" id="cleanupIntervalHours" value="{{ cleanupIntervalHours }}" class="form-control" min="1" max="24">
                    <small class="form-text text-muted">
                        How often to automatically clean up orphan files (1-24 hours).
                    </small>
                </div>
            </div>

        </div>

        <!-- Download API Settings -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>API Download Configuration</h4>
            <p class="text-muted">These options, along with the Chrome extension, will let you `right-click` links and send them to CLU to be downloaded to your <code>/watch</code> folder.</p>

            <div class="row">
                <div class="col-md-6">
                    <label for="customHeaders" class="form-label">Custom Headers (JSON)</label>
                    <textarea class="form-control" id="customHeaders" name="customHeaders" rows="4" placeholder="JSON Custom Headers">{{ customHeaders }}</textarea>
                    <small class="form-text text-muted">
                        Similar to the Chrome Extension, enter any authentication details here that need to be passed to your URL/domain/Tunnel/VPN.
                    </small>
                </div>

                <div class="col-md-6">
                    <label for="pixeldrainApiKey" class="form-label">PixelDrain API Key</label>
                    <input type="password" name="pixeldrainApiKey" id="pixeldrainApiKey" value="{{ pixeldrainApiKey }}" class="form-control" placeholder="Enter your PixelDrain API key">
                    <small class="form-text text-muted">
                        Optional: Enter your PixelDrain API key for authenticated downloads. This enables access to private files and higher download limits.
                    </small>
                </div>
            </div>
        </div>

        <!-- Performance & Timeout Settings -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Performance & Timeout Settings</h4>
            <p class="text-muted">Configure timeout settings for large file operations and performance optimizations.</p>

            <div class="row">
                <div class="col-md-6">
                    <label for="operationTimeout" class="form-label">Operation Timeout (seconds):</label>
                    <input type="number" name="operationTimeout" id="operationTimeout" value="{{ operationTimeout }}" class="form-control" min="300" max="7200">
                    <small class="form-text text-muted">
                        Timeout for large file operations (convert, rebuild). Default: 3600 seconds (1 hour). Minimum: 300 seconds (5 minutes).
                    </small>
                </div>

                <div class="col-md-6">
                    <label for="largeFileThreshold" class="form-label">Large File Threshold (MB):</label>
                    <input type="number" name="largeFileThreshold" id="largeFileThreshold" value="{{ largeFileThreshold }}" class="form-control" min="100" max="2000">
                    <small class="form-text text-muted">
                        Files larger than this size (in MB) will get enhanced progress reporting. Default: 500 MB.
                    </small>
                </div>
            </div>
        </div>

        <!-- Cache Management Settings -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Cache Management</h4>
            <p class="text-muted">
                Manage the application's directory cache and search index. The cache automatically rebuilds every 6 hours to ensure data accuracy.
                <br><br>
                <strong>How it works:</strong> When you browse directories, the app caches the listing for 5 seconds to improve performance. 
                If files change (downloads, moves, etc.), the cache is automatically invalidated. The search index provides fast file searching 
                across your entire data directory.
            </p>

            <!-- Cache Status Display -->
            <div class="row mb-3">
                <div class="col-md-12">
                    <div class="alert alert-info">
                        <div class="row">
                            <div class="col-md-4">
                                <strong>Cache Status:</strong><br>
                                <span id="cacheStatus">Checking...</span>
                            </div>
                            <div class="col-md-4">
                                <strong>Data Directory:</strong><br>
                                <span id="dataDirStatus">Checking...</span>
                            </div>
                            <div class="col-md-4">
                                <strong>Next Rebuild:</strong><br>
                                <span id="nextRebuild">Calculating...</span>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-md-12">
                                <small class="text-muted">
                                    <span id="cacheDetails">Loading cache details...</span>
                                </small>
                            </div>
                        </div>
                        <div class="row mt-1">
                            <div class="col-md-12">
                                <small class="text-muted">
                                    <span id="cachePerformance">Loading performance info...</span>
                                </small>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-md-12 text-center">
                                <button type="button" class="btn btn-sm btn-outline-info" onclick="updateCacheStatus()" title="Refresh cache status">
                                    <i class="bi bi-arrow-clockwise"></i> Refresh Status
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cache Management Buttons -->
            <div class="row">
                <div class="col-md-6">
                    <button type="button" class="btn btn-outline-primary w-100" onclick="rebuildCache()" title="Rebuild cache and search index">
                        <i class="bi bi-arrow-clockwise"></i> Rebuild Cache
                    </button>
                    <small class="form-text text-muted">
                        Manually rebuild the entire directory cache and search index. This will clear all cached data and rebuild it from scratch.
                    </small>
                </div>

                <div class="col-md-6">
                    <button type="button" class="btn btn-outline-secondary w-100" onclick="clearCache()" title="Clear directory cache">
                        <i class="bi bi-trash"></i> Clear Cache
                    </button>
                    <small class="form-text text-muted">
                        Clear the directory cache only. This will force the next directory listing to rebuild the cache, but won't affect the search index.
                    </small>
                </div>
            </div>

            <!-- Cache Configuration -->
            <div class="row mt-3">
                <div class="col-md-4">
                    <label for="cacheRebuildInterval" class="form-label">Cache Rebuild Interval (hours):</label>
                    <input type="number" name="cacheRebuildInterval" id="cacheRebuildInterval" value="6" class="form-control" min="1" max="24" readonly>
                    <small class="form-text text-muted">
                        How often the cache automatically rebuilds. Currently set to 6 hours and cannot be changed from the UI.
                    </small>
                </div>

                <div class="col-md-4">
                    <label for="cacheDuration" class="form-label">Cache Duration (seconds):</label>
                    <input type="number" name="cacheDuration" id="cacheDuration" value="5" class="form-control" min="1" max="60" readonly>
                    <small class="form-text text-muted">
                        How long individual directory listings are cached. Currently set to 5 seconds and cannot be changed from the UI.
                    </small>
                </div>

                <div class="col-md-4">
                    <label for="maxCacheSize" class="form-label">Maximum Cache Size:</label>
                    <input type="number" name="maxCacheSize" id="maxCacheSize" value="100" class="form-control" readonly>
                    <small class="form-text text-muted">
                        Maximum number of directories that can be cached in memory. Currently set to 100 and cannot be changed from the UI.
                    </small>
                </div>
            </div>
        </div>

        <!-- Custom Rename Pattern Configuration -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>Custom Rename Pattern Settings</h4>
            <p class="text-muted">Configure custom patterns for renaming comic files. You can use variables to create your own naming convention, or leave empty to use the default rename logic.</p>

            <div class="row">
                <div class="col-md-12">
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" role="switch" id="enableCustomRename" name="enableCustomRename" {% if enableCustomRename %}checked{% endif %}>
                        <label class="form-check-label" for="enableCustomRename">{% if enableCustomRename %}Disable{% else %}Enable{% endif %} Custom Rename Patterns</label>
                        <small class="form-text text-muted">
                            <br />If enabled, files will be renamed using your custom pattern instead of the default rename logic.
                        </small>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-md-8">
                    <label for="customRenamePattern" class="form-label">Custom Rename Pattern:</label>
                    <input type="text" name="customRenamePattern" id="customRenamePattern" value="{{ customRenamePattern }}" class="form-control" placeholder="e.g., {series_name} {issue_number} ({year})">
                    <small class="form-text text-muted">
                        Use variables to create your naming pattern. Available variables: <code>{series_name}</code>, <code>{volume_number}</code>, <code>{year}</code>, <code>{issue_number}</code>
                    </small>
                </div>
                <div class="col-md-4">
                    <label class="form-label">Example Preview:</label>
                    <div class="border rounded p-2 bg-light">
                        <small id="renamePreview">Enter a pattern to see preview...</small>
                    </div>
                </div>
            </div>

            <div class="row mt-2">
                <div class="col-md-12">
                    <small class="text-muted">
                        <strong>Examples:</strong><br>
                        ‚Ä¢ <code>{series_name} {issue_number} ({year})</code> ‚Üí <code>Spider-Man 2099 044 (1992).cbz</code><br>
                        ‚Ä¢ <code>{series_name} [{year}] {issue_number}</code> ‚Üí <code>Spider-Man 2099 [1992] 044.cbz</code><br>
                        ‚Ä¢ <code>issue{issue_number}</code> ‚Üí <code>issue001.cbz</code><br>
                        ‚Ä¢ <code>{volume_number}_{issue_number}</code> ‚Üí <code>v2_044.cbz</code>
                    </small>
                </div>
            </div>
        </div>

        <!-- ComicInfo XML editing Configuration -->
        <div class="container p-4 border rounded shadow-sm mb-4">
            <h4>ComicInfo.XML Update Settings</h4>
            <p class="text-muted">Enable/Disable features for updating or cleaning <code>ComicInfo.xml</code> files. This proecess runs on a single directory, extracts the <code>ComicInfo.xml</code> file, reads and makes updates and then recompresses the file.</p>

            <!-- Checkboxes for ComicInfo.xml options -->
            <div class="row">
                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="xmlYear" name="xmlYear" {% if xmlYear %}checked{% endif %}>
                        <label class="form-check-label" for="xmlYear">{% if xmlYear %}Disable{% else %}Enable{% endif %} Update Volume to First Issue Year</label>
                        <small class="form-text text-muted">
                            <br />Reads the alpha-numeric first file in the directory and attempts to extract the 4-digit year from the filename.
                        </small>
                    </div>
                </div>

                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input xml-checkbox" type="checkbox" role="switch" id="xmlMarkdown" name="xmlMarkdown" {% if xmlMarkdown %}checked{% endif %}>
                        <label class="form-check-label" for="xmlMarkdown">{% if xmlMarkdown %}Disable{% else %}Enable{% endif %} Removing ALL Markdown Content from Comments</label>
                        <small class="form-text text-muted">
                            <br />If enabled, when the ComicInfo.xml update function is run, the <code>Comments</code> will have all headers, bold text and tables removed.
                        </small>
                    </div>
                </div>

                <div class="col-md-4">
                    <div class="form-check form-switch">
                        <input class="form-check-input xml-checkbox" type="checkbox" role="switch" id="xmlList" name="xmlList" {% if xmlList %}checked{% endif %}>
                        <label class="form-check-label" for="xmlList">{% if xmlList %}Disable{% else %}Enable{% endif %} Removing 'Covers & Creators' table from Comments</label>
                        <small class="form-text text-muted">
                            <br />If enabled, when the ComicInfo.xml update function is run, 'Covers & Creators' tables will be removed from the <code>Comments</code>.
                        </small>
                    </div>
                </div>

            </div>
        </div>

        <!-- Save Button -->
        <div class="mb-3 text-center">
            <button type="submit" class="btn btn-primary">
                <i class="bi bi-floppy"></i> Save
            </button>
        </div>
    </form>

    <!-- Restart Button -->
    <div class="container p-4 border rounded shadow-sm text-center">
        <h6>Restart Flask App</h6>
        <button onclick="restartApp()" class="btn btn-secondary">Restart App</button>
    </div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    function restartApp() {
        fetch('/restart', { method: 'POST' })
        .then(response => response.json())
        .then(data => alert(data.message))
        .catch(error => console.error('Error:', error));
    }
    
    document.addEventListener("DOMContentLoaded", function () {
        const xmlCheckboxes = document.querySelectorAll(".xml-checkbox");

       xmlCheckboxes.forEach(checkbox => {
            checkbox.addEventListener("change", function () {
                if (this.checked) {
                    xmlCheckboxes.forEach(cb => {
                        if (cb !== this) {
                            cb.checked = false;
                        }
                    });
                }
            });
        });

        // Initialize custom rename pattern preview
        initializeRenamePreview();

        // Initialize cache status display with a slight delay to avoid blocking page load
        setTimeout(updateCacheStatus, 1000);
        
        // Update cache status every 5 minutes instead of every minute to reduce server load
        setInterval(updateCacheStatus, 300000);
    });

    // Cache Management Functions
    function rebuildCache() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        
        // Show loading state
        button.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Rebuilding...';
        button.disabled = true;
        
        fetch('/rebuild-cache', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showToast('Cache Rebuilt', data.message, 'success');
                // Update cache status display
                updateCacheStatus();
            } else {
                showToast('Cache Rebuild Failed', data.error || 'Unknown error', 'error');
            }
        })
        .catch(error => {
            console.error('Error rebuilding cache:', error);
            showToast('Cache Rebuild Failed', 'Network error occurred', 'error');
        })
        .finally(() => {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
        });
    }

    function clearCache() {
        const button = event.target.closest('button');
        const originalText = button.innerHTML;
        
        // Show loading state
        button.innerHTML = '<i class="bi bi-trash"></i> Clearing...';
        button.disabled = true;
        
        fetch('/clear-cache', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showToast('Cache Cleared', 'Directory cache cleared successfully', 'success');
                // Update cache status display
                updateCacheStatus();
            } else {
                showToast('Cache Clear Failed', data.error || 'Unknown error', 'error');
            }
        })
        .catch(error => {
            console.error('Error clearing cache:', error);
            showToast('Cache Clear Failed', 'Network error occurred', 'error');
        })
        .finally(() => {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
        });
    }

    // Update cache status display
    function updateCacheStatus() {
        // First try the lightweight endpoint for quick response
        updateCacheStatusLight();
    }
    
    function updateCacheStatusLight() {
        // Show loading state
        const cacheStatusEl = document.getElementById('cacheStatus');
        if (cacheStatusEl) {
            cacheStatusEl.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Updating...';
        }
        
        // Add timeout to prevent hanging requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout for light endpoint
        
        fetch('/cache-status-light', { 
            signal: controller.signal,
            headers: { 'Cache-Control': 'no-cache' } // Ensure fresh data
        })
            .then(response => {
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                // Update basic cache status immediately
                updateBasicCacheStatus(data);
                
                // Then try to get full statistics in background
                setTimeout(() => updateCacheStatusFull(), 1000);
                
                // Set a fallback timeout in case detailed stats take too long
                setTimeout(() => {
                    const dataDirStatusEl = document.getElementById('dataDirStatus');
                    if (dataDirStatusEl && dataDirStatusEl.textContent.includes('Loading detailed stats')) {
                        dataDirStatusEl.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Detailed stats unavailable (timeout)';
                    }
                }, 10000); // 10 second fallback
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error('Error fetching light cache status:', error);
                
                // Show error state briefly
                const cacheStatusEl = document.getElementById('cacheStatus');
                if (cacheStatusEl) {
                    cacheStatusEl.innerHTML = '<i class="bi bi-exclamation-triangle"></i> Update failed';
                }
                
                // If light endpoint fails, try the full endpoint as fallback after a delay
                setTimeout(() => updateCacheStatusFull(), 2000);
                
                // Retry the light endpoint after a longer delay
                setTimeout(() => updateCacheStatusLight(), 30000);
            });
    }
    
    function updateCacheStatusFull() {
        // Add timeout to prevent hanging requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout for full endpoint
        
        fetch('/cache-status', { 
            signal: controller.signal,
            headers: { 'Cache-Control': 'no-cache' } // Ensure fresh data
        })
            .then(response => {
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                updateFullCacheStatus(data);
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error('Error fetching full cache status:', error);
                
                // Don't show error for full endpoint failure, just log it
                // The basic status should already be displayed from the light endpoint
            });
    }
    
    function updateBasicCacheStatus(data) {
        const cacheStatusEl = document.getElementById('cacheStatus');
        const nextRebuildEl = document.getElementById('nextRebuild');
        const cacheDetailsEl = document.getElementById('cacheDetails');
        const cachePerformanceEl = document.getElementById('cachePerformance');
        
        if (cacheStatusEl && nextRebuildEl && cacheDetailsEl && cachePerformanceEl) {
            // Update basic cache status
            const cachedDirs = data.cache_size;
            const statusText = `${cachedDirs} dirs cached | Last: ${data.formatted_since} ago`;
            cacheStatusEl.textContent = statusText;
            
            // Update next rebuild time
            if (data.time_until_next > 0) {
                nextRebuildEl.textContent = `in ${data.formatted_until}`;
            } else {
                nextRebuildEl.textContent = 'Due now';
            }
            
            // Update cache details
            let detailsText = '';
            if (data.cache_invalidated) {
                detailsText += '‚ö†Ô∏è Cache was recently invalidated by file changes. ';
            }
            if (data.index_built) {
                detailsText += '‚úÖ Search index is ready. ';
            } else {
                detailsText += '‚è≥ Building search index... ';
            }
            detailsText += `Cache duration: ${data.cache_duration || 5}s | Max cache size: ${data.max_cache_size || 100}`;
            
            cacheDetailsEl.textContent = detailsText;
            
            // Update basic cache performance information
            let performanceText = `Cache efficiency: ${cachedDirs}/${data.max_cache_size || 100}`;
            
            if (cachedDirs >= (data.max_cache_size || 100)) {
                performanceText += ' | ‚ö†Ô∏è Cache at maximum size';
            }
            
            if (cachedDirs === 0) {
                performanceText = 'üîÑ Cache is empty, will rebuild on next access';
            }
            
            cachePerformanceEl.textContent = performanceText;
            
            // Set data directory status to loading
            const dataDirStatusEl = document.getElementById('dataDirStatus');
            if (dataDirStatusEl) {
                dataDirStatusEl.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Loading detailed stats...';
            }
        }
    }
    
    function updateFullCacheStatus(data) {
        const cacheStatusEl = document.getElementById('cacheStatus');
        const dataDirStatusEl = document.getElementById('dataDirStatus');
        const nextRebuildEl = document.getElementById('nextRebuild');
        const cacheDetailsEl = document.getElementById('cacheDetails');
        const cachePerformanceEl = document.getElementById('cachePerformance');
        
        if (cacheStatusEl && nextRebuildEl && dataDirStatusEl && cacheDetailsEl && cachePerformanceEl) {
            // Update cache status with more detail
            const cachedDirs = data.cache_size;
            const totalDirs = data.total_directories || 'Unknown';
            const statusText = `${cachedDirs}/${totalDirs} dirs cached | Last: ${data.formatted_since} ago`;
            cacheStatusEl.textContent = statusText;
            
            // Update data directory status
            if (data.data_dir_stats) {
                const stats = data.data_dir_stats;
                let dirStatusText = `${stats.subdir_count} subdirs | ${stats.total_files} files`;
                
                // Add indicators for limited scans
                if (stats.scan_limited) {
                    dirStatusText += ' (scan limited)';
                }
                if (stats.max_depth_reached > 0) {
                    dirStatusText += ` | Max depth: ${stats.max_depth_reached}`;
                }
                if (stats.scan_time > 0) {
                    dirStatusText += ` | Scan time: ${stats.scan_time}s`;
                }
                
                dataDirStatusEl.textContent = dirStatusText;
                
                // Show response time if available
                if (data.response_time) {
                    const cacheDetailsEl = document.getElementById('cacheDetails');
                    if (cacheDetailsEl) {
                        cacheDetailsEl.textContent += ` | Response time: ${data.response_time}s`;
                    }
                }
            } else {
                dataDirStatusEl.textContent = 'Stats unavailable';
            }
            
            // Update next rebuild time
            if (data.time_until_next > 0) {
                nextRebuildEl.textContent = `in ${data.formatted_until}`;
            } else {
                nextRebuildEl.textContent = 'Due now';
            }
            
            // Update cache details
            let detailsText = '';
            if (data.cache_invalidated) {
                detailsText += '‚ö†Ô∏è Cache was recently invalidated by file changes. ';
            }
            if (data.index_built) {
                detailsText += '‚úÖ Search index is ready. ';
            } else {
                detailsText += '‚è≥ Building search index... ';
            }
            detailsText += `Cache duration: ${data.cache_duration || 5}s | Max cache size: ${data.max_cache_size || 100}`;
            
            cacheDetailsEl.textContent = detailsText;
            
            // Update cache performance information
            const cacheHitRate = data.total_directories > 0 ? 
                Math.round((data.cache_size / data.total_directories) * 100) : 0;
            let performanceText = `Cache hit rate: ${cacheHitRate}% | `;
            
            if (data.cache_size >= data.max_cache_size) {
                performanceText += '‚ö†Ô∏è Cache at maximum size | ';
            }
            
            if (data.cache_size === 0) {
                performanceText += 'üîÑ Cache is empty, will rebuild on next access';
            } else {
                performanceText += `Cache efficiency: ${data.cache_size}/${data.max_cache_size}`;
            }
            
            cachePerformanceEl.textContent = performanceText;
        }
    }

    // Helper function to show toast notifications
    function showToast(title, message, type = 'info') {
        // Create toast element
        const toastHtml = `
            <div class="toast bg-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} text-white" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header bg-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} text-white">
                    <strong class="me-auto">${title}</strong>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            </div>
        `;
        
        // Create toast container if it doesn't exist
        let toastContainer = document.querySelector('.toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
            toastContainer.style.zIndex = '1100';
            document.body.appendChild(toastContainer);
        }
        
        const toastElement = document.createElement('div');
        toastElement.innerHTML = toastHtml;
        toastContainer.appendChild(toastElement.firstElementChild);
        
        // Show the toast
        const toast = new bootstrap.Toast(toastElement.firstElementChild);
        toast.show();
        
        // Remove toast element after it's hidden
        toastElement.firstElementChild.addEventListener('hidden.bs.toast', function() {
            toastElement.remove();
        });
    }

    // Custom Rename Pattern Preview Functions
    function initializeRenamePreview() {
        const patternInput = document.getElementById('customRenamePattern');
        const previewElement = document.getElementById('renamePreview');
        
        if (patternInput && previewElement) {
            // Add event listeners for live preview
            patternInput.addEventListener('input', updateRenamePreview);
            patternInput.addEventListener('change', updateRenamePreview);
            
            // Initial preview
            updateRenamePreview();
        }
    }
    
    function updateRenamePreview() {
        const patternInput = document.getElementById('customRenamePattern');
        const previewElement = document.getElementById('renamePreview');
        
        if (!patternInput || !previewElement) return;
        
        const pattern = patternInput.value.trim();
        if (!pattern) {
            previewElement.textContent = 'Enter a pattern to see preview...';
            return;
        }
        
        // Sample values for preview
        const sampleValues = {
            series_name: 'Spider-Man 2099',
            volume_number: 'v2',
            year: '1992',
            issue_number: '044'
        };
        
        try {
            const preview = applyCustomPattern(sampleValues, pattern);
            previewElement.textContent = preview + '.cbz';
        } catch (error) {
            previewElement.textContent = 'Invalid pattern';
        }
    }
    
    function applyCustomPattern(values, pattern) {
        // Simple pattern replacement for preview
        let result = pattern;
        
        // Replace variables with sample values
        result = result.replace(/\{series_name\}/g, values.series_name || '');
        result = result.replace(/\{volume_number\}/g, values.volume_number || '');
        result = result.replace(/\{year\}/g, values.year || '');
        result = result.replace(/\{issue_number\}/g, values.issue_number || '');
        
        // Clean up extra spaces
        result = result.replace(/\s+/g, ' ').trim();
        
        return result;
    }
</script>
{% endblock %}