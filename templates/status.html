{% extends 'base.html' %}

{% block title %}Download Status{% endblock %}

{% block content %}
<style>
  .action-icon {
    transition: all 0.2s ease;
    padding: 5px;
    border-radius: 4px;
  }
  
  .action-icon:hover {
    transform: scale(1.1);
    background-color: rgba(0,0,0,0.1);
  }
  
  .text-danger.action-icon:hover {
    background-color: rgba(220,53,69,0.1);
  }
  
  .text-primary.action-icon:hover {
    background-color: rgba(13,110,253,0.1);
  }
</style>

<div class="container my-5">
    <h2>Download Status</h2>
    <button id="clear-downloads-btn" class="btn btn-primary mb-3">
      Clear Completed/Cancelled Downloads (Preserves Errors)
    </button>
    <table class="table table-striped" id="downloads-table">
      <thead>
        <tr>
          <th>Filename</th>
          <th>Progress</th>
          <th>Downloaded</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>
{% endblock %}

{% block scripts %}
{{ super() }}
    <script>
    // Function to fetch all download statuses and update the table.
    function fetchStatus() {
      fetch('/download_status_all')
        .then(response => response.json())
        .then(data => {
          const tbody = document.querySelector('#downloads-table tbody');
          tbody.innerHTML = ''; // Clear previous rows.
          for (const [downloadId, details] of Object.entries(data)) {
            const tr = document.createElement('tr');

            // Filename - display only the base file name.
            const tdFilename = document.createElement('td');
            if (details.filename) {
              tdFilename.textContent = details.filename.split('/').pop();
            } else {
              tdFilename.textContent = 'N/A';
            }
            tr.appendChild(tdFilename);

            // Progress with a Bootstrap progress bar.
            const tdProgress = document.createElement('td');
            const progressBar = document.createElement('div');
            progressBar.className = 'progress';
            const progressInner = document.createElement('div');
            progressInner.className = 'progress-bar';
            progressInner.style.width = details.progress + '%';
            progressInner.setAttribute('aria-valuenow', details.progress);
            progressInner.setAttribute('aria-valuemin', '0');
            progressInner.setAttribute('aria-valuemax', '100');
            progressInner.textContent = details.progress + '%';
            progressBar.appendChild(progressInner);
            tdProgress.appendChild(progressBar);
            tr.appendChild(tdProgress);

            // Downloaded Bytes
            const tdBytes = document.createElement('td');
            if (details.bytes_total && details.bytes_downloaded) {
              const mb = (bytes => (bytes / (1024 * 1024)).toFixed(2));
              tdBytes.textContent = `${mb(details.bytes_downloaded)} MB / ${mb(details.bytes_total)} MB`;
            } else {
              tdBytes.textContent = 'â€”';
            }
            tr.appendChild(tdBytes);

            // Status
            const tdStatus = document.createElement('td');
            tdStatus.textContent = details.status;
            
            // Add visual styling for error status
            if (details.status === 'error') {
              tdStatus.className = 'text-danger fw-bold';
            } else if (details.status === 'completed') {
              tdStatus.className = 'text-success';
            } else if (details.status === 'cancelled') {
              tdStatus.className = 'text-warning';
            }
            
            tr.appendChild(tdStatus);

            // Actions cell (Cancel/Retry buttons)
            const tdActions = document.createElement('td');
            
            if (details.status === 'in_progress') {
              // Cancel button for in-progress downloads
              const cancelIcon = document.createElement('i');
              cancelIcon.className = "bi bi-x-circle text-danger action-icon";
              cancelIcon.style.cursor = "pointer";
              cancelIcon.style.fontSize = "1.2em";
              cancelIcon.title = "Cancel download";
              cancelIcon.addEventListener('click', () => {
                showConfirmToast('Are you sure you want to cancel this download?', () => {
                  fetch(`/cancel_download/${downloadId}`, { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                      console.log(data.message);
                      showToast('Download cancelled', 'success');
                      // Optionally, update the UI immediately.
                    })
                    .catch(error => {
                      showToast('Error cancelling download', 'error');
                    });
                });
              });
              tdActions.appendChild(cancelIcon);
            } else if (details.status === 'error') {
              // Retry button for error status
              const retryIcon = document.createElement('i');
              retryIcon.className = "bi bi-arrow-clockwise text-primary action-icon";
              retryIcon.style.cursor = "pointer";
              retryIcon.style.fontSize = "1.2em";
              retryIcon.title = "Retry download";
              retryIcon.addEventListener('click', () => {
                showConfirmToast('Are you sure you want to retry this download?', () => {
                  fetch(`/retry_download/${downloadId}`, { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                      console.log(data.message);
                      showToast('Download retried', 'success');
                      // Refresh the table to show updated status
                      fetchStatus();
                    })
                    .catch(error => {
                      console.error('Error retrying download:', error);
                      showToast('Error retrying download', 'error');
                    });
                });
              });
              tdActions.appendChild(retryIcon);
            } else {
              // No action buttons for completed/cancelled downloads
              tdActions.textContent = '';
            }
            tr.appendChild(tdActions);

            tbody.appendChild(tr);
          }
        });
    }

    // Event listener for the Clear Completed/Cancelled Downloads button.
    document.getElementById('clear-downloads-btn').addEventListener('click', function() {
      showConfirmToast('This will clear all completed and cancelled downloads. Downloads with errors will be preserved. Continue?', () => {
        fetch('/clear_downloads', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            console.log(data.message);
            showToast('Downloads cleared', 'success');
            // Refresh the table after clearing
            fetchStatus();
          })
          .catch(error => {
            console.error('Error clearing downloads:', error);
            showToast('Error clearing downloads', 'error');
          });
      });
    });

    // Poll the status endpoint every second.
    setInterval(fetchStatus, 1000);
    fetchStatus();

    // Toast notification system for status.html
    function showToast(message, type = 'info', duration = 5000) {
        // Create toast container if it doesn't exist
        let container = document.getElementById('toast-container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'toast-container';
            container.className = 'toast-container position-fixed top-0 end-0 p-3';
            container.style.zIndex = '9999';
            document.body.appendChild(container);
        }

        const toastId = 'toast-' + Date.now();
        const iconMap = {
            'success': 'bi-check-circle-fill text-success',
            'error': 'bi-exclamation-triangle-fill text-danger',
            'warning': 'bi-exclamation-triangle-fill text-warning',
            'info': 'bi-info-circle-fill text-info'
        };

        const toastHtml = `
            <div id="${toastId}" class="toast bg-white border-0 shadow" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header">
                    <i class="bi ${iconMap[type]} me-2"></i>
                    <strong class="me-auto">${type.charAt(0).toUpperCase() + type.slice(1)}</strong>
                    <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', toastHtml);
        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement, {
            delay: duration,
            autohide: duration > 0
        });

        toast.show();

        // Remove from DOM after hiding
        toastElement.addEventListener('hidden.bs.toast', () => {
            toastElement.remove();
        });

        return toast;
    }

    // Confirmation toast with Yes/No buttons
    function showConfirmToast(message, callback) {
        const container = document.getElementById('toast-container') || (() => {
            const div = document.createElement('div');
            div.id = 'toast-container';
            div.className = 'toast-container position-fixed top-0 end-0 p-3';
            div.style.zIndex = '9999';
            document.body.appendChild(div);
            return div;
        })();

        const toastId = 'confirm-toast-' + Date.now();
        const toastHtml = `
            <div id="${toastId}" class="toast bg-white border-0 shadow" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header">
                    <i class="bi bi-question-circle-fill text-warning me-2"></i>
                    <strong class="me-auto">Confirm</strong>
                    <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
                <div class="toast-body">
                    <p class="mb-3">${message}</p>
                    <div class="d-flex gap-2">
                        <button type="button" class="btn btn-danger btn-sm confirm-yes">Yes</button>
                        <button type="button" class="btn btn-secondary btn-sm confirm-no">No</button>
                    </div>
                </div>
            </div>
        `;

        container.insertAdjacentHTML('beforeend', toastHtml);
        const toastElement = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastElement, {
            autohide: false // Don't auto-hide confirmation toasts
        });

        // Add event listeners for Yes/No buttons
        toastElement.querySelector('.confirm-yes').addEventListener('click', () => {
            callback();
            toast.hide();
        });

        toastElement.querySelector('.confirm-no').addEventListener('click', () => {
            toast.hide();
        });

        toast.show();

        // Remove from DOM after hiding
        toastElement.addEventListener('hidden.bs.toast', () => {
            toastElement.remove();
        });

        return toast;
    }
    </script>
{% endblock %}
